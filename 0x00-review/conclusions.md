# 一些有用的小结论&tips
- 给定一个区间`[l, r]`，包含下标为`k`的子区间的个数为`(k - l + 1) * (r - k + 1)`
- 给定一个无序的序列，规定只能交换相邻元素，那么将数组变为有序的最少交换次数就是整个数组的逆序对数目
- 可以用树状数组 + 二分查找整个序列中第k大的数字，为每个数字维护计数值不是1就是0，找到最小的i使得`a[i]`的前缀和等于k
- C++中cin只能读取不包含空格的字符串，可以使用`getline(cin, s);`的方式读取空格，以回车作为结束符
- C++中使用自定义函数的优先队列
    ```cpp
    auto cmp = [&](int i, int j) -> bool {
        return a[i] > a[j];
    };
    priority_queue<int, vector<int>, decltype(cmp)> h(cmp);
    // 这是小顶堆的
    ```
- 有些思路就是自己像的那样，只是麻烦了一点