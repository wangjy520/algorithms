# 一些有用的小结论&tips
- 给定一个区间`[l, r]`，包含下标为`k`的子区间的个数为`(k - l + 1) * (r - k + 1)`
- 给定一个无序的序列，规定只能交换相邻元素，那么将数组变为有序的最少交换次数就是整个数组的逆序对数目
- 可以用树状数组 + 二分查找整个序列中第k大的数字，为每个数字维护计数值不是1就是0，找到最小的i使得`a[i]`的前缀和等于k
- C++中cin只能读取不包含空格的字符串，可以使用`getline(cin, s);`的方式读取空格，以回车作为结束符